# Codebase quality
Overall I would say this codebase is of high quality, despite finding a relatively high number of issues. Given the huge scope and complexity it's not unexpected to have a large number of issues at this stage, so if we're considering the number of lines per issue, the figure is actually quite low. Most of the issues I've found aren't trivial so I definitely get the impression the authors have written this codebase with security in mind. For the most part the cross chain components appear to be pretty solid which I like to see as an auditor considering this is one of the most complex parts of the codebase and is often where issues are found.

In terms of the test suite, I would highly recommend a rewrite/restructure of practically all the tests. Firstly, a huge number of the tests are so long that it's really hard to follow what the key functionality being tested is; I'd consider them almost like module tests rather than unit tests. In my opinion many of the tests aren't very readable and require a tonne of reasoning to understand what the core goal of the test is. A good test suite should be readable to anyone, not just the original author. From past experience I would recommend moving to Foundry to write more compact unit tests. I used to be a firm advocate for Hardhat but having moved to Foundry I really feel like you can write a more robust test suite, particularly around timing edge cases. Due to this difficulty understanding the test suite and being able to quickly and easily modify tests I have not been able to write PoCs for the issues I have submitted. I usually write a PoC for every non-trivial issue, but every time I tried to modify the existing test suite I'd break something else as everything was so intertwined.

Regarding re-entrancy I think it's clear from the architecture of this codebase that the developers have a very strong understanding of this vulnerability. Rather than seeing `nonReentrant` plastered all over the codebase, the public/external methods instead consistently use the Checks-Effects-Interactions pattern to ensure that even when a reentrant call is performed nothing bad can be achieved (at least I was not able to find any vulnerabilities that stemmed from reentrancy).

# Architecture feedback
The key piece of feedback I have regarding the architecture of the codebase is around the parts that are receiving messages on the destination chain from LayerZero. At the moment most methods are using a storage slot to check whether or not a specific message has already been credited, just in the case the underlying delegatecall fails. However, this whole credit checking and balance transfer on failure mechanism being used is unnecessary because the context is reverted if the underlying delegate call fails. The context is reverted so that the message can be saved for retrying later again (the whole idea behind the LZ non blocking receive). By removing all of this unnecessary logic you will save gas and reduce code complexity for all cross-chain calls.

Whilst we're on the topic of cross-chain messages via LayerZero, I think the current architecture design of delegatecalling to modules from USDO and TOFT tokens is a nice way of doing it. Not only does it reduce the deployment size of the relevant contracts, but it also helps to keep similar code logically separate. Especially since all the modules inherit the same storage contract as the base contract, it ensures the computation performed is all performed in exactly the same context, no matter the module used; it should make future deployments (e.g. for Tapioca V2) easier to implement in code.

The worst part of the codebase architecture in my opinion was the Magnetar contract. The idea for the contract is to be a helper to interact with the rest of the Tapioca ecosystem, but to be honest I don't feel like it's really helping; for the most part it's just forwarding calls whilst adding complexity. It's true that it creates a single entrypoint, but I'm not sure this outweighs the added risk and complexity. If it were me I'd probably remove the Magnetar contract from the Ecosystem, at least until it can provide a significant benefit to the end user.

I can't finish this feedback section with anything else but the YieldBox contracts. I was impressed by how simple the code was considering the integral part of the YieldBox contract throughout the Tapioca ecosystem. Keeping the core as simple as possible massively reduces the scope for future issues. There isn't anything major I'd change here, but I am slightly concerned about the permissionless strategies. These strategies have a tonne of power in the YieldBox and can be used to steal funds in a number of ways. In fact it's pretty easy to siphon funds from a strategy contract without being noticed by the depositors of the asset id. My recommendation here would be to make it super clear in the UI which strategies are verified/written by Tapioca, and highlighting the danger of interacting with YieldBox assets that have non-verified strategies.

# Risks
As mentioned above, I see the permissionless YieldBox strategies as a pretty large potential risk, so I would like to see this mitigated as much as possible.

Beyond this, I am also slightly concerned about the USDO peg considering there is no variable mint fee implemented. I've talked about this more in one of the issues I've submitted, but just to highlight this, I'd really like to see the variable mint fee implemented that is mentioned in your documentation to ensure sustained downward pressure isn't put on the USDO token. I feel like if this token crashes, Tapioca crashes with it. The token is so intertwined with the whole project that the peg really needs as much protection as it can get. For more confidence in the token peg it could be worth getting in touch with teams like Chaos Labs that can perform simulations of real scenarios to test the integrity of the peg.

In terms of centralisation risk I don't feel like there is too much concern to be had here. Yes, the owners of some contracts have the ability to change relevant parameters, but there weren't any points where I was too worried about a little centralisation. However, despite saying this, I would encourage you to use a multi-tiered owner system if that was not already your plan. By this I mean that the owners of some contract should be different to the owners of other contracts. For example, the strategy owners should not be a governance timelock contract or anything similar as otherwise it completely defeats the point of being able to make an emergency withdraw. However other owners like that for the Penrose contract should probably be owned by governance so that changes are only made after a voting period. This multi-tiered setup strikes a balance between lack of centralisation and being able to react in times of need.

# Final recommendations
I anticipate this initial audit will have a relatively high number of issues, so the mitigation review will be of high importance. I see there is already a significant portion of the prize pool set aside for the mitigation review which I think is the right approach, but I would also recommend having a final follow up with a couple of auditors familiar with the codebase after the mitigation review (assuming more fixes after the mitigation review) - this could save you lots of money in the long term to avoid an early high-value find in the bug bounty program.

And just to double down on the above, the test suite really need to be more modular and needs to stress more of the edge cases. 100% line coverage doesn't mean 100% coverage!

I'm excited to see Tapioca launch, it's one of the coolest projects I've seen for a while.

### Time spent:
60 hours