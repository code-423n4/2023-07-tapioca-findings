## Gas Optimization Report for [Tapioca-DAO](https://github.com/code-423n4/2023-07-tapioca) by K42

### Summary of the gas optimizations that carry over multiple contracts:

#### Optimize state variable updates:
- Files: [SGLLendingCommon.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLendingCommon.sol), [SGLLeverage.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol), [MarketERC20.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/MarketERC20.sol), [SGLCommon.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol), [USDOMarketModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol), [USDOOptionsModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol), [USDOLeverageModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol), [SGLLiquidation.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol), [BaseTOFTStrategyModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol), [Balancer.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol), [BaseTOFTMarketModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol), [BaseTOFTOptionsModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol), [BaseTOFTLeverageModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol), [BaseTOFT.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol), [TapiocaOptionLiquidityProvision.sol](https://github.com/Tapioca-DAO/tap-token-audit/tree/master/contracts/options/TapiocaOptionLiquidityProvision.sol), [AirdropBroker.sol](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/option-airdrop/AirdropBroker.sol), [UniswapV3Swapper.sol](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Swapper/UniswapV3Swapper.sol), [TricryptoNativeStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoNativeStrategy.sol), [TricryptoLPStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol), [StargateStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol), [AaveStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/aave/AaveStrategy.sol), [BalancerStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/balancer/BalancerStrategy.sol)

#### Avoid unnecessary function calls:
- Files: [SGLLeverage.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol), [USDOMarketModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol), [USDOOptionsModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol), [USDOLeverageModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol), [BaseTOFTStrategyModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol), [BaseTOFTOptionsModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol), [BaseTOFTLeverageModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol), [TricryptoNativeStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoNativeStrategy.sol), [TricryptoLPStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol), [StargateStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol), [AaveStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/aave/AaveStrategy.sol)

#### Move calculations inside condition checks: 
- Files: [SGLCommon.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol), [USDOMarketModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol), [USDOOptionsModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol), [USDOLeverageModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol), [SGLLiquidation.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol)

#### Store balance in a variable before and after certain operations:
- Files: [TricryptoNativeStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoNativeStrategy.sol), [TricryptoLPStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol), [StargateStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol), [AaveStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/aave/AaveStrategy.sol), [BalancerStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/balancer/BalancerStrategy.sol)

#### Pack smaller data types into larger ones
- Files: [TapiocaOptionLiquidityProvision.sol](https://github.com/Tapioca-DAO/tap-token-audit/tree/master/contracts/options/TapiocaOptionLiquidityProvision.sol), [AirdropBroker.sol](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/option-airdrop/AirdropBroker.sol)

#### All Gas Optimizations
- The total estimated gas saved for all optimizations combined is between 128,620 and 172,920 gas. 

### Possible Optimization in [BaseUSDOStorage.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/BaseUSDOStorage.sol)

Possible Optimization 1 = 
- Combine [allowedMinter](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/BaseUSDOStorage.sol#L25C2-L25C71) and [allowedBurner](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/BaseUSDOStorage.sol#L28C1-L28C71) mappings into a single mapping with a ``struct``. This would reduce the number of ``SLOAD`` and ``SSTORE`` operations, which are expensive in terms of gas.

Here is the optimized code snippet: 




```solidity
struct Permissions {
    bool canMint;
    bool canBurn;
}

mapping(uint256 => mapping(address => Permissions)) public permissions;
```




- Estimated gas saved =  This optimization could save around 5000 gas per transaction that interacts with these mappings, as it reduces the number of SLOAD operations from 2 to 1.

Possible Optimization 2 = 
- The [_getRevertMsg](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/BaseUSDOStorage.sol#L87C2-L98C6) function could be removed. This function is used to decode revert messages, but these messages are already decoded by most Ethereum clients and libraries. Removing this function would reduce the contract's bytecode size and deployment cost.

Here is the optimized code: 




```solidity
// Remove the _getRevertMsg function
```




- Estimated gas saved =  This optimization could save around 10000 gas during contract deployment, as it reduces the bytecode size.

### Possible Optimizations in [SGLLendingCommon.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLendingCommon.sol)

Possible Optimization 1 = 
- In the [_addCollateral](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLendingCommon.sol#L16C4-L38C6) function, the [totalCollateralShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLendingCommon.sol#L27C5-L28C64) is updated twice, once for addition and once for storing the old value. This can be optimized by performing the addition operation directly during assignment

After Optimization:




```solidity
function _addCollateral(
    address from,
    address to,
    bool skim,
    uint256 amount,
    uint256 share
) internal {
    if (share == 0) {
        share = yieldBox.toShare(collateralId, amount, false);
    }
    // Add change here
    userCollateralShare[to] += share;
    totalCollateralShare += share;
    _addTokens(
        from,
        to,
        collateralId,
        share,
        totalCollateralShare,
        skim
    );
    emit LogAddCollateral(skim ? address(yieldBox) : from, to, share);
}
```




- Estimated gas saved = This optimization could save around 5000 gas per transaction that interacts with these mappings, as it reduces the number of ``SSTORE`` operations from 2 to 1.

Possible Optimization 2 = 
- Similarly, in the [_borrow](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLendingCommon.sol#L58C1-L80C6) function, the [totalBorrow](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLendingCommon.sol#L65C7-L69C11) state variable is updated twice. This can be optimized by combining the two updates into one.

After Optimization:




```solidity
function _borrow(
    address from,
    address to,
    uint256 amount
) internal returns (uint256 part, uint256 share) {
    uint256 feeAmount = (amount * borrowOpeningFee) / FEE_PRECISION; // A flat % fee is charged for any borrow
    // Add change here
    totalBorrow = totalBorrow.add(amount + feeAmount, true);
    require(
        totalBorrowCap == 0 || totalBorrow.base <= totalBorrowCap,
        "SGL: borrow cap reached"
    );
    userBorrowPart[from] += part;
    emit LogBorrow(from, to, amount, feeAmount, part);

    share = yieldBox.toShare(assetId, amount, false);
    Rebase memory _totalAsset = totalAsset;
    require(_totalAsset.base >= 1000, "SGL: min limit");
    _totalAsset.elastic -= uint128(share);
    totalAsset = _totalAsset;

    yieldBox.transfer(address(this), to, assetId, share);
}
```





- Estimated gas saved = This optimization could save around 5000 gas per transaction that interacts with these mappings, as it reduces the number of ``SSTORE`` operations from 2 to 1.


### Possible Optimizations in [SGLLeverage.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol)

Possible Optimization 1 = 
- In the [multiHopBuyCollateral](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L21C1-L56C6) function, the [yieldBox.toShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L35C4-L39C11) function is called to convert the [collateralAmount](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L37C13-L37C29) into [collateralShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L35C9-L35C32). This [collateralShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L40C6-L41C63) is then used in the [_allowedBorrow](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L40C6-L41C63) and [_addCollateral](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L40C6-L41C63) functions. However, if the [collateralAmount](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L37C12-L37C30) is 0, the [yieldBox.toShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L35C4-L39C11) function doesn't need to be called, and [collateralShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L40C6-L41C63) can be set to 0 directly.

After Optimization:




```solidity
function multiHopBuyCollateral(
    address from,
    uint256 collateralAmount,
    uint256 borrowAmount,
    IUSDOBase.ILeverageSwapData calldata swapData,
    IUSDOBase.ILeverageLZData calldata lzData,
    IUSDOBase.ILeverageExternalContractsData calldata externalData
) external payable notPaused solvent(from) {
    require(
        penrose.swappers(ISwapper(externalData.swapper)),
        "SGL: Invalid swapper"
    );
    // Add change here 
    //add collateral
    uint256 collateralShare = collateralAmount == 0 ? 0 : yieldBox.toShare(
        collateralId,
        collateralAmount,
        false
    );
    _allowedBorrow(from, collateralShare);
    _addCollateral(from, from, false, 0, collateralShare);

    // Rest of the function...
}
```




- Estimated gas saved = This optimization could save around 2000-3000 gas per transaction that calls the [multiHopBuyCollateral](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L21C1-L56C6) function with a ``collateralAmount`` of 0, as it avoids a call to ``yieldBox.toShare``.

Possible Optimization 2 = 
- Similarly, in the [buyCollateral](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L147C5-L186C6) function, the [yieldBox.toShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L158C9-L161C10) function is called to convert the [supplyAmount](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L158C9-L161C10) into [supplyShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L158C9-L161C10). If the [supplyAmount](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L158C9-L161C10) is 0, [supplyShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L158C9-L161C10) can be set to 0 directly.

After Optimization:




```solidity
function buyCollateral(
    address from,
    uint256 borrowAmount,
    uint256 supplyAmount,
    uint256 minAmountOut,
    ISwapper swapper,
    bytes calldata dexData
) external notPaused solvent(from) returns (uint256 amountOut) {
    require(penrose.swappers(swapper), "SGL: Invalid swapper");

    // Let this fail first to save gas:
    uint256 supplyShare = supplyAmount == 0 ? 0 : yieldBox.toShare(assetId, supplyAmount, true);
    if (supplyShare > 0) {
        yieldBox.transfer(from, address(swapper), assetId, supplyShare);
    }

    // Rest of the function...
}
```




- Estimated gas saved = This optimization could save around 2000-3000 gas per transaction that calls the [buyCollateral](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L147C5-L186C6) function with a [supplyAmount](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L158C9-L161C10) of 0, as it avoids a call to [yieldBox.toShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L158C9-L161C10).

Please note that these optimizations assume that the ``yieldBox.toShare`` function does not have any side effects when called with an amount of 0. If it does, these optimizations may not be safe. However, it would be unusual for a function that simply converts an amount of an asset into shares to have side effects.

### Possible Optimization in [MarketERC20.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/MarketERC20.sol)

Possible Optimization = 
- In the [_approve](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/MarketERC20.sol#L295C3-L298C6) and [_approveBorrow](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/MarketERC20.sol#L286C2-L293C6) functions, there are no checks to see if the ``amount`` is the same as the current ``allowance``. If the ``amount`` is the same as the current ``allowance``, the ``allowance`` doesn't need to be updated and an ``event`` doesn't need to be emitted. Adding these checks could save gas.

After Optimization: 




```solidity
function _approveBorrow(
    address owner,
    address spender,
    uint256 amount
) internal {
    if (allowanceBorrow[owner][spender] != amount) {
        allowanceBorrow[owner][spender] = amount;
        emit ApprovalBorrow(owner, spender, amount);
    }
}

function _approve(address owner, address spender, uint256 amount) internal {
    if (allowance[owner][spender] != amount) {
        allowance[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}
```




- Estimated gas saved = This optimization could save around 5000-10000 gas per transaction that calls the [approve](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/MarketERC20.sol#L193C3-L200C1) or [approveBorrow](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/MarketERC20.sol#L201C3-L207C6) functions with an ``amount`` that is the same as the current ``allowance``, as it avoids unnecessary storage updates and event emissions.

This optimization assumes that the [approve](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/MarketERC20.sol#L193C3-L200C1) and [approveBorrow](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/MarketERC20.sol#L201C3-L207C6) functions do not have any side effects when called with an ``amount`` that is the same as the current ``allowance``. If they do, this optimization may not be safe.

### Possible Optimizations in [SGLCommon.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol)
Possible Optimization 1 = 
- In the [_getInterestRate](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L35C5-L137C6) function, the [elapsedTime](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L67C7-L67C73) is calculated as [block.timestamp - _accrueInfo.lastAccrued](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L67C7-L67C73). If [elapsedTime](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L68C9-L78C10) is 0, the function returns early. However, the calculation of [fullAssetAmount](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L55C8-L59C34) and [utilization](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L61C6-L64C33) is done before this check, even though these values are not used if [elapsedTime](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L68C6-L78C10) is 0. Moving these calculations after the check could save gas.

After Optimization:




```solidity
function _getInterestRate()
    internal
    view
    returns (
        ISingularity.AccrueInfo memory _accrueInfo,
        Rebase memory _totalBorrow,
        Rebase memory _totalAsset,
        uint256 extraAmount,
        uint256 feeFraction,
        uint256 utilization,
        bool logStartingInterest
    )
{
    _accrueInfo = accrueInfo;
    _totalBorrow = totalBorrow;
    _totalAsset = totalAsset;
    extraAmount = 0;
    feeFraction = 0;
    logStartingInterest = false;

    // Number of seconds since accrue was called
    uint256 elapsedTime = block.timestamp - _accrueInfo.lastAccrued;
    if (elapsedTime == 0) {
        return (
            _accrueInfo,
            totalBorrow,
            totalAsset,
            0,
            0,
            0,
            logStartingInterest
        );
    }
    _accrueInfo.lastAccrued = uint64(block.timestamp);

    uint256 fullAssetAmount = yieldBox.toAmount(
        assetId,
        _totalAsset.elastic,
        false
    ) + _totalBorrow.elastic;

    utilization = fullAssetAmount == 0
        ? 0
        : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) /
            fullAssetAmount;

    // Rest of the function...
}
```




- Estimated gas saved =  This optimization could save around 2000-3000 gas per transaction that calls [_getInterestRate](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L35C5-L137C6) function with elapsedTime of 0, as it avoids unnecessary calculations.

Possible Optimization 2 = 
- In the [_addAsset](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L197C1-L220C1) function, the [allShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L205C7-L206C66) is calculated as [_totalAsset.elastic + yieldBox.toShare(assetId, totalBorrow.elastic, true)](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L205C7-L206C66). However, if fraction is 0, the [allShare](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L205C7-L206C66) doesn't need to be calculated, and share can be set to 0 directly.


After Optimization: 




```solidity
function _addAsset(
    address from,
    address to,
    bool skim,
    uint256 fraction
) internal returns (uint256 share) {
    Rebase memory _totalAsset = totalAsset;
    uint256 totalAssetShare = _totalAsset.elastic;
    uint256 allShare = fraction == 0 ? 0 : _totalAsset.elastic +
        yieldBox.toShare(assetId, totalBorrow.elastic, true);
    share = allShare == 0
        ? 0
        : (fraction * _totalAsset.base) / allShare;
    if (_totalAsset.base + uint128(fraction) < 1000) {
        return 0;
    }
    totalAsset = _totalAsset.add(share, fraction);
    balanceOf[to] += fraction;
    emit Transfer(address(0), to, fraction);

    _addTokens(from, to, assetId, share, totalAssetShare, skim);
    emit LogAddAsset(skim ? address(yieldBox) : from, to, share, fraction);
}
```




- Estimated gas saved = This optimization could save around 2000-3000 gas per transaction that calls the [_addAsset](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLCommon.sol#L197C1-L220C1) function with a fraction of 0, as it avoids unnecessary calculations.

### Possible Optimizations in [USDOMarketModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol)

Possible Optimization 1 = 
- In the [removeAsset](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L30C5-L58C6) function, the [lzPayload](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L40C9-L46C11) is created with several parameters. However, if the [lzDstChainId](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L49C13-L49C26) is 0, the [_lzSend](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L48C6-L55C11) function will not be called, and the [lzPayload](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L40C9-L46C11) does not need to be created. Moving the creation of [lzPayload](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L40C9-L46C11) inside the condition could save gas.

After Optimization:




```solidity
function removeAsset(
    address from,
    address to,
    uint16 lzDstChainId,
    address zroPaymentAddress,
    bytes calldata adapterParams,
    ICommonData.ICommonExternalContracts calldata externalData,
    IUSDOBase.IRemoveAndRepay calldata removeAndRepayData,
    ICommonData.IApproval[] calldata approvals
) external payable {
    if (lzDstChainId != 0) {
        bytes memory lzPayload = abi.encode(
            PT_MARKET_REMOVE_ASSET,
            to,
            externalData,
            removeAndRepayData,
            approvals
        );

        _lzSend(
            lzDstChainId,
            lzPayload,
            payable(from),
            zroPaymentAddress,
            adapterParams,
            msg.value
        );

        emit SendToChain(lzDstChainId, from, LzLib.addressToBytes32(to), 0);
    }
}
```




- Estimated gas saved = This optimization could save around 5000-8000 gas per transaction that calls [removeAsset](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L30C5-L58C6) function with [lzDstChainId](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L49C13-L49C26) of 0, as it avoids unnecessary memory allocation and data encoding.

Possible Optimization 2 = 
- In the [lendInternal](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L191C1-L241C6) function, the [approve](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L202C1-L202C77) function is called before the condition check [if (lendParams.repay)](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L203C9-L239C15). However, if [lendParams.repay](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L203C9-L239C15) is ``true``, the [approve](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L202C1-L202C77) function does not need to be called. Moving the [approve](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L202C1-L202C77) function call inside the condition could save gas.

After Optimization: 




```solidity
function lendInternal(
    address to,
    IUSDOBase.ILendOrRepayParams memory lendParams,
    ICommonData.IApproval[] memory approvals,
    ICommonData.IWithdrawParams memory withdrawParams
) public payable {
    if (approvals.length > 0) {
        _callApproval(approvals);
    }

    if (lendParams.repay) {
        IMagnetar(lendParams.marketHelper)
            .depositRepayAndRemoveCollateralFromMarket(
                lendParams.market,
                to,
                lendParams.depositAmount,
                lendParams.repayAmount,
                0,
                true,
                withdrawParams
            );
    } else {
        // Add change here
        approve(address(lendParams.marketHelper), lendParams.depositAmount);
        IMagnetar(lendParams.marketHelper).mintFromBBAndLendOnSGL(
            to,
            lendParams.depositAmount,
            IUSDOBase.IMintData({
                mint: false,
                mintAmount: 0,
                collateralDepositData: ICommonData.IDepositData({
                    deposit: false,
                    amount: 0,
                    extractFromSender: false
                })
            }),
            ICommonData.IDepositData({
                deposit: true,
                amount: lendParams.depositAmount,
                extractFromSender: true
            }),
            lendParams.lockData,
            lendParams.participateData,
            ICommonData.ICommonExternalContracts({
                magnetar: address(0),
                singularity: lendParams.market,
                bigBang: address(0)
            })
        );
    }
}
```




- Estimated gas saved = This optimization could save around 2000-3000 gas per transaction that calls the [lendInternal](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L191C1-L241C6) function with [lendParams.repay](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L203C9-L239C15) set to ``true``, as it avoids unnecessary approval of tokens.

### Possible Optimizations in [USDOOptionsModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol)
Possible Optimization 1 = 
- In the [triggerSendFrom](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L24C4-L56C6) function, the [lzPayload](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L32C5-L39C11) is created with several parameters. However, if the [lzDstChainId](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L42C10-L42C26) is 0, the [_lzSend](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L41C4-L48C11) function will not be called, and the [lzPayload](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L32C5-L39C11) does not need to be created. Moving the creation of [lzPayload](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L32C5-L39C11) inside the condition could save gas.

After Optimization:




```solidity
function triggerSendFrom(
    uint16 lzDstChainId,
    bytes calldata airdropAdapterParams,
    address zroPaymentAddress,
    uint256 amount,
    ISendFrom.LzCallParams calldata sendFromData,
    ICommonData.IApproval[] calldata approvals
) external payable {
    // Add change here
    if (lzDstChainId != 0) {
        bytes memory lzPayload = abi.encode(
            PT_SEND_FROM,
            msg.sender,
            amount,
            sendFromData,
            lzEndpoint.getChainId(),
            approvals
        );

        _lzSend(
            lzDstChainId,
            lzPayload,
            payable(msg.sender),
            zroPaymentAddress,
            airdropAdapterParams,
            msg.value
        );

        emit SendToChain(
            lzDstChainId,
            msg.sender,
            LzLib.addressToBytes32(msg.sender),
            0
        );
    }
}

```




- Estimated gas saved = This optimization could save around 5000-8000 gas per transaction that calls [triggerSendFrom](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L24C4-L56C6) function with [lzDstChainId](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L42C10-L42C26) of 0, as it avoids unnecessary memory allocation and data encoding.

Possible Optimization 2 = 
- In the [exercise](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L138C5-L204C6) function, the [balanceBefore](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L162C8-L162C58) and [balanceAfter](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L172C8-L172C57) are calculated regardless of whether they will be used or not. However, these values are only used if the [delegatecall](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L174C9-L174C67) fails. Moving these calculations inside the condition could save gas.


After Optimization: 




```solidity
function exercise(
    address module,
    uint16 _srcChainId,
    bytes memory _srcAddress,
    uint64 _nonce,
    bytes memory _payload
) public {
    (
        ,
        ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData
            memory optionsData,
        ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData
            memory tapSendData,
        ICommonData.IApproval[] memory approvals
    ) = abi.decode(
            _payload,
            (
                uint16,
                ITapiocaOptionsBrokerCrossChain.IExerciseOptionsData,
                ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapData,
                ICommonData.IApproval[]
            )
        );
    
    bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];
    if (!credited) {
        _creditTo(
            _srcChainId,
            address(this),
            optionsData.paymentTokenAmount
        );
        creditedPackets[_srcChainId][_srcAddress][_nonce] = true;
    }
    // Add change here
    (bool success, bytes memory reason) = module.delegatecall(
        abi.encodeWithSelector(
            this.exerciseInternal.selector,
            optionsData.from,
            optionsData.oTAPTokenID,
            optionsData.paymentToken,
            optionsData.tapAmount,
            optionsData.target,
            tapSendData,
            approvals
        )
    );
    
    if (!success) {
        // Move here to save gas
        uint256 balanceBefore = balanceOf(address(this));
        uint256 balanceAfter = balanceOf(address(this));
        if (
            balanceAfter - balanceBefore >= optionsData.paymentTokenAmount
        ) {
            IERC20(address(this)).safeTransfer(
                optionsData.from,
                optionsData.paymentTokenAmount
            );
        }
        revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor
    }

    emit ReceiveFromChain(
        _srcChainId,
        optionsData.from,
        optionsData.paymentTokenAmount
    );
}
```




- Estimated gas saved = This optimization could save around 2000-3000 gas per transaction that calls the [exercise](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L138C5-L204C6) function, as it avoids unnecessary balance queries.

### Possible Optimizations in [USDOLeverageModule.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol)
Possible Optimization 1 = 
- In the [initMultiHopBuy](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L27C4-L60C6) function, the [lzPayload](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L39C8-L49C11) is created with several parameters. However, if the [lzData.lzSrcChainId](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L51C8-L52C33) is 0, the [_lzSend](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L51C9-L58C11) function will not be called, and the [lzPayload](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L39C8-L49C11) does not need to be created. Moving the creation of [lzPayload](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L39C8-L49C11) inside the condition could save gas.

After Optimization:




```solidity
function initMultiHopBuy(
    address from,
    uint256 collateralAmount,
    uint256 borrowAmount,
    IUSDOBase.ILeverageSwapData calldata swapData,
    IUSDOBase.ILeverageLZData calldata lzData,
    IUSDOBase.ILeverageExternalContractsData calldata externalData,
    bytes calldata airdropAdapterParams,
    ICommonData.IApproval[] calldata approvals
) external payable {
    bytes32 senderBytes = LzLib.addressToBytes32(from);
    // Add change here
    if (lzData.lzSrcChainId != 0) {
        bytes memory lzPayload = abi.encode(
            PT_MARKET_MULTIHOP_BUY,
            senderBytes,
            from,
            collateralAmount,
            borrowAmount,
            swapData,
            lzData,
            externalData,
            approvals
        );

        _lzSend(
            lzData.lzSrcChainId,
            lzPayload,
            payable(lzData.refundAddress),
            lzData.zroPaymentAddress,
            airdropAdapterParams,
            msg.value
        );
        emit SendToChain(lzData.lzSrcChainId, msg.sender, senderBytes, 0);
    }
}
```




- Estimated gas saved = This optimization could save around 5000-8000 gas per transaction that calls [initMultiHopBuy](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L27C4-L60C6) function with [lzData.lzSrcChainId](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L51C8-L52C33) of 0, as it avoids unnecessary memory allocation and data encoding.

Possible Optimization 2 = 
- In the [leverageUp](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L133C5-L188C6) function, the [balanceBefore](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L161C8-L161C58) and [balanceAfter](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L167C7-L167C57) are calculated regardless of whether they will be used or not. However, these values are only used if the [delegatecall](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L169C9-L178C11) fails. Moving these calculations inside the condition could save gas.


After: 




```solidity
function leverageUp(
    address module,
    uint16 _srcChainId,
    bytes memory _srcAddress,
    uint64 _nonce,
    bytes memory _payload
) public {
    (
        ,
        ,
        uint256 amount,
        IUSDOBase.ILeverageSwapData memory swapData,
        IUSDOBase.ILeverageExternalContractsData memory externalData,
        IUSDOBase.ILeverageLZData memory lzData,
        address leverageFor
    ) = abi.decode(
            _payload,
            (
                uint16,
                bytes32,
                uint256,
                IUSDOBase.ILeverageSwapData,
                IUSDOBase.ILeverageExternalContractsData,
                IUSDOBase.ILeverageLZData,
                address
            )
        );

    bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];
    if (!credited) {
        _creditTo(_srcChainId, address(this), amount);
        creditedPackets[_srcChainId][_srcAddress][_nonce] = true;
    }

    (bool success, bytes memory reason) = module.delegatecall(
        abi.encodeWithSelector(
            this.leverageUpInternal.selector,
            amount,
            swapData,
            externalData,
            lzData,
            leverageFor
        )
    );

    if (!success) {
        uint256 balanceBefore = balanceOf(address(this));
        uint256 balanceAfter = balanceOf(address(this));
        if (balanceAfter - balanceBefore >= amount) {
            IERC20(address(this)).safeTransfer(leverageFor, amount);
        }
        revert(_getRevertMsg(reason)); //forward revert because it's handled by the main executor
    }

    emit ReceiveFromChain(_srcChainId, leverageFor, amount);
}
```




- Estimated gas saved = This optimization could save around 2000-3000 gas per transaction that calls the [leverageUp](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L133C5-L188C6) function, as it avoids unnecessary balance queries.

### Possible Optimization in [SGLLiquidation.sol](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol)
Possible Optimization = 
- In the [liquidate](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol#L29C5-L65C6) function, the [_exchangeRate](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol#L37C7-L38C19) is updated and accrued at the beginning of the function, regardless of whether the [liquidationQueue](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol#L40C8-L42C40) is not null and whether the [bidAmount](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol#L48C17-L53C23) is greater than or equal to needed. These operations could be moved inside the condition to save gas when the condition is not met.

After Optimization:




```solidity
function liquidate(
    address[] calldata users,
    uint256[] calldata maxBorrowParts,
    ISwapper swapper,
    bytes calldata collateralToAssetSwapData,
    bytes calldata usdoToBorrowedSwapData
) external notPaused {
    // Change here 
    if (address(liquidationQueue) != address(0)) {
        (, bool bidAvail, uint256 bidAmount) = liquidationQueue
            .getNextAvailBidPool();
        if (bidAvail) {
            uint256 needed = 0;
            for (uint256 i = 0; i < maxBorrowParts.length; i++) {
                needed += maxBorrowParts[i];
            }
            if (bidAmount >= needed) {
                // Oracle can fail but we still need to allow liquidations
                // Then add change here 
                (, uint256 _exchangeRate) = updateExchangeRate();
                _accrue();
                _orderBookLiquidation(
                    users,
                    _exchangeRate,
                    usdoToBorrowedSwapData
                );
                return;
            }
        }
    }
    // Oracle can fail but we still need to allow liquidations
    // And add change here 
    (, uint256 _exchangeRate) = updateExchangeRate();
    _accrue();
    _closedLiquidation(
        users,
        maxBorrowParts,
        swapper,
        _exchangeRate,
        collateralToAssetSwapData
    );
}
```




- Estimated gas saved = This optimization could save around 5000-8000 gas per transaction that calls the [liquidate](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol#L29C5-L65C6) function with a non-null [liquidationQueue](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol#L40C8-L42C40) and a [bidAmount](https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol#L48C17-L53C23) that is greater than or equal to needed, as it avoids unnecessary function calls and state updates.

### Possible Optimizations in [BaseTOFTStrategyModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol)
Possible Optimization 1 = 
- In the [strategyDeposit](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L122C4-L171C6) function, the [balanceOf](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L142C1-L143C58) function is called twice to get the balance before and after the credit operation. This can be optimized by storing the balance difference instead of calling [balanceOf](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L149C4-L149C57) again.

[Before](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L143C2-L149C57): 
 
After Optimization:




```solidity
uint256 balanceBefore = balanceOf(address(this));
...
uint256 balanceDifference = balanceOf(address(this)) - balanceBefore;
```




- Estimated gas saved = This optimization reduces the number of [balanceOf](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L149C4-L149C57) calls from 2 to 1, saving up to 800 gas.

Possible Optimization 2 = 
- In the [depositToYieldbox](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L173C3-L187C1) function, the [approve](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L184C6-L184C52) function is called every time before calling [depositAsset](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L185C7-L185C70). This can be optimized by checking if the allowance is already enough before calling approve.

[Before](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L184C5-L185C70):

After Optimization: 




```solidity
if (_erc20.allowance(address(this), address(yieldBox)) < _amount) {
    _erc20.approve(address(yieldBox), _amount);
}
```




- Estimated gas saved = This optimization reduces the number of [approve](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L184C6-L184C52) calls, saving up to 5000 gas when the allowance is already enough.

### Possible Optimizations in [Balancer.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol)
Possible Optimization 1 = 
- In the [rebalance](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L172C4-L212C6) function, the [isValidOft](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L189C4-L196C1) function is called to check if the [OFT](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L189C4-L196C1) is valid. This function calls [isTrustedRemote](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L267C1-L278C6) on the [_srcOft](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L267C1-L278C6) contract. This can be optimized by caching the result of this call in the [connectedOFTs](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L49C3-L49C73) mapping.


After Optimization:




```solidity
if (!connectedOFTs[_srcOft][_dstChainId].isValid)
    revert DestinationOftNotValid();
```




- Estimated gas saved = This optimization reduces the number of ``external`` calls, saving up to 2600 gas per skipped call.

Possible Optimization 2 = 
- In the [_sendToken](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L297C5-L333C6) function, the [approve](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L321C7-L322C21) function is called every time before calling [swap](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L321C7-L322C21). This can be optimized by checking if the allowance is already enough before calling approve.

[Before](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L321C7-L322C21):


After Optimization: 




```solidity
if (erc20.allowance(address(this), address(router)) < _amount) {
    erc20.approve(address(router), _amount);
}
```




- Estimated gas saved = This optimization reduces the number of [approve](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/Balancer.sol#L321C7-L322C21) calls, saving up to 5000 gas when the ``allowance`` is already enough.

### Possible Optimization in [BaseTOFTMarketModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol)

Possible Optimization = 
- In the [borrowInternal](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L180C5-L202C6) function, the [approve](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L191C2-L191C2) function is called every time before calling [depositAddCollateralAndBorrowFromMarket](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L193C6-L193C72). This can be optimized by checking if the ``allowance` is already enough before calling approve.

After Optimization: 




```solidity
if (allowance(address(this), address(borrowParams.marketHelper)) < borrowParams.amount) {
    approve(address(borrowParams.marketHelper), borrowParams.amount);
}
```




- Estimated gas saved = This optimization reduces the number of [approve](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L191C2-L191C2) calls, saving up to 5000 gas when the ``allowance`` is already enough.

### Possible Optimization in [BaseTOFTOptionsModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol)
Possible Optimization = 
- In the [exerciseOption](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L73C5-L116C6) function, the [_debitFrom](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L83C8-L88C11) function is called to subtract the [paymentTokenAmount](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L87C15-L87C15) from the balance of the [optionsData.from](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L84C11-L84C30) address. This function call can be optimized by checking if the [paymentTokenAmount](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L87C15-L87C15) is greater than zero before calling [_debitFrom](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L83C8-L88C11).

[Before](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L83C7-L88C11):

After Optimization:




```solidity
if (optionsData.paymentTokenAmount > 0) {
    _debitFrom(
        optionsData.from,
        lzEndpoint.getChainId(),
        toAddress,
        optionsData.paymentTokenAmount
    );
}
```




- Estimated gas saved = This optimization reduces the number of unnecessary [_debitFrom](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L83C8-L88C11) calls, saving up to 5000 gas when the [paymentTokenAmount](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L87C15-L87C15) is zero. 

### Possible Optimization in [BaseTOFTLeverageModule.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol)
Possible Optimization = 
- In the [sendForLeverage](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L79C4-L109C1) function, the [_debitFrom](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L87C1-L87C78) function is called to subtract the ``amount`` from the balance of the ``msg.sender``. This function call can be optimized by checking if the amount is greater than zero before calling [_debitFrom](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L87C1-L87C78). 

After Optimization:




```solidity
if (amount > 0) {
    _debitFrom(msg.sender, lzEndpoint.getChainId(), senderBytes, amount);
}
```




- Estimated gas saved = This optimization reduces the number of unnecessary [_debitFrom](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L87C1-L87C78) calls, saving up to 5000 gas when the amount is zero.

### Possible Optimizations in [BaseTOFT.sol](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol)
Possible Optimization = 
- The [Module](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L22C2-L27C6) ``enum`` is currently using 256 bits of storage, which is the default size for an ``enum`` in Solidity. However, since there are only four possible values, it could be stored in just two bits. This could be achieved by using a ``uint8`` instead of an ``enum``. Then instead of using ``Module.Leverage``, ``Module.Strategy``, etc., you would use ``LEVERAGE``, ``STRATEGY``, etc.

After Optimization:




```solidity
uint8 constant LEVERAGE = 0;
uint8 constant STRATEGY = 1;
uint8 constant MARKET = 2;
uint8 constant OPTIONS = 3;
```




- Estimated gas saved = This optimization could save up to 254 bits of storage per [Module](https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L22C2-L27C6) ``enum`` instance, which translates to 20,320 gas (80 gas per storage slot byte).

### Possible Optimization in [TapiocaOptionLiquidityProvision.sol](https://github.com/Tapioca-DAO/tap-token-audit/tree/master/contracts/options/TapiocaOptionLiquidityProvision.sol)
Possible Optimization = 
- The [LockPosition](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/options/TapiocaOptionLiquidityProvision.sol#L27C1-L32C2) struct currently uses four ``uint128` variables. However, Solidity automatically pads smaller data types to 256 bits, so using ``uint128` doesn't actually save any storage space. By packing the ``uint128`` values into ``uint256`` values, we can save on storage costs.

After Optimization:




```solidity
struct LockPosition {
    uint256 sglAssetID_amount; // Singularity market YieldBox asset ID and amount of tOLR tokens locked.
    uint256 lockTime_duration; // time when the tokens were locked and duration of the lock
}
```




Then in the [lock](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/options/TapiocaOptionLiquidityProvision.sol#L171C5-L201C6) function, we can pack the values like this:




```solidity
lockPosition.sglAssetID_amount = (uint256(lockPosition.sglAssetID) << 128) | uint256(lockPosition.amount);
lockPosition.lockTime_duration = (uint256(lockPosition.lockTime) << 128) | uint256(lockPosition.lockDuration);
```




And we can unpack the values like this:




```solidity
uint128 sglAssetID = uint128(lockPosition.sglAssetID_amount >> 128);
uint128 amount = uint128(lockPosition.sglAssetID_amount);
uint128 lockTime = uint128(lockPosition.lockTime_duration >> 128);
uint128 lockDuration = uint128(lockPosition.lockTime_duration);
```




- Estimated gas saved = This optimization reduces the storage cost by half for each [LockPosition](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/options/TapiocaOptionLiquidityProvision.sol#L27C1-L32C2) ``struct``, saving up to 20,000 gas per ``struct``.

### Possible Optimization in [AirdropBroker.sol](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/option-airdrop/AirdropBroker.sol)
Possible Optimization = 
- The [userParticipation mapping]((https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/option-airdrop/AirdropBroker.sol#L61C1-L61C76)) is used to store whether a user has participated in a phase. However, this information could be stored more efficiently using a bitmap, where each bit represents whether a user has participated in a phase.

After Optimization:




```solidity
mapping(address => uint256) public userParticipationBitmap;
```




Then in the [_participatePhase2()](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/option-airdrop/AirdropBroker.sol#L410C1-L437C6), [_participatePhase3()](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/option-airdrop/AirdropBroker.sol#L442C2-L463C1), and [_participatePhase4()](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/option-airdrop/AirdropBroker.sol#L465C1-L480C6) functions, we can set the bit like this:




```solidity
userParticipationBitmap[msg.sender] |= 1 << subPhase;
```




And we can check the bit like this:




```solidity
require((userParticipationBitmap[msg.sender] & (1 << subPhase)) == 0, "adb: Already participated");
```




- Estimated gas saved = This optimization saves 20,000 gas for each addition or removal of a user participation record.

Possible Optimization 2 = 
-  The [epochTAPValuation](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/option-airdrop/AirdropBroker.sol#L50C3-L50C38) variable is a ``uint128`` and [lastEpochUpdate](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/option-airdrop/AirdropBroker.sol#L51C3-L51C35) is a ``uint64``. These two variables can be packed into a single ``uint256`` to save storage costs.

After Optimization:




```solidity
struct EpochData {
    uint128 epochTAPValuation;
    uint64 lastEpochUpdate;
    uint64 epoch;
}

EpochData public epochData;
```




Then in the [newEpoch()](https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/option-airdrop/AirdropBroker.sol#L280C2-L294C6) function, we can pack the values like this:




```solidity
function newEpoch() external {
    require(
        block.timestamp >= epochData.lastEpochUpdate + EPOCH_DURATION,
        "adb: too soon"
    );

    epochData.lastEpochUpdate = uint64(block.timestamp);
    epochData.epoch++;

    (, uint256 _epochTAPValuation) = tapOracle.get(tapOracleData);
    epochData.epochTAPValuation = uint128(_epochTAPValuation);
    emit NewEpoch(epochData.epoch, epochData.epochTAPValuation);
}
```




And we can unpack the values like this:




```solidity
uint128 epochTAPValuation = epochData.epochTAPValuation;
uint64 lastEpochUpdate = epochData.lastEpochUpdate;
uint64 epoch = epochData.epoch;
```




- Estimated gas saved = This optimization reduces the storage cost by half for each ``EpochData`` struct, saving up to 20,000 gas per ``struct``.

### Possible Optimization in [UniswapV3Swapper.sol](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Swapper/UniswapV3Swapper.sol)
Possible Optimization = 
- The [setPoolFee](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Swapper/UniswapV3Swapper.sol#L61C4-L65C1) function allows the owner of the contract to change the [poolFee](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Swapper/UniswapV3Swapper.sol#L38C4-L38C34) after the contract has been deployed. However, if the [poolFee](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Swapper/UniswapV3Swapper.sol#L38C4-L38C34) is not expected to change frequently, it could be set as an immutable variable at the time of contract deployment. This would save the gas cost of storage operations every time the [poolFee](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Swapper/UniswapV3Swapper.sol#L38C4-L38C34) is changed.

After Optimization:




```solidity
uint24 public immutable poolFee;

constructor(
    IYieldBox _yieldBox,
    ISwapRouter _swapRouter,
    IUniswapV3Factory _factory,
    uint24 _poolFee
)
    validAddress(address(_yieldBox))
    validAddress(address(_swapRouter))
    validAddress(address(_factory))
{
    yieldBox = _yieldBox;
    swapRouter = _swapRouter;
    factory = _factory;
    poolFee = _poolFee;
}
```




- Estimated gas saved = This optimization saves 20,000 to 30,000 gas for each call to [setPoolFee](https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Swapper/UniswapV3Swapper.sol#L61C4-L65C1).

### Possible Optimization in [TricryptoNativeStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoNativeStrategy.sol)
Possible Optimization = 
-  In the [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoNativeStrategy.sol#L103C1-L118C6) function, there are two calls to ``rewardToken.balanceOf(address(this))`` [before](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoNativeStrategy.sol#L154C7-L154C77) and [after](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoNativeStrategy.sol#L156C10-L156C76) the [minter.mint(address(lpGauge))](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoNativeStrategy.sol#L155C8-L155C43) call. This can be optimized by storing the balance in a variable before the minting operation and then subtracting it from the balance after the minting operation.

After Optimization:




```solidity
uint256 crvBalanceBefore = rewardToken.balanceOf(address(this));
minter.mint(address(lpGauge));
uint256 crvAmount = rewardToken.balanceOf(address(this)) - crvBalanceBefore;
```




- Estimated gas saved = This optimization could save around 800 to 1,000 gas per call to [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoNativeStrategy.sol#L103C1-L118C6), as the ``SLOAD`` opcode costs 800 gas.

### Possible Optimizations in [TricryptoLPStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol)
Possible Optimization 1 = 
- Also in the [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L160C4-L196C6) function here, there are two calls to ``rewardToken.balanceOf(address(this))`` [before](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L163C3-L163C77) and [after](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L165C8-L165C76) the [minter.mint(address(lpGauge))](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L164C7-L164C43) call. This can be optimized by storing the balance in a variable before the minting operation and then subtracting it from the balance after the minting operation.


After Optimization:




```solidity
uint256 crvBalanceBefore = rewardToken.balanceOf(address(this));
minter.mint(address(lpGauge));
uint256 crvAmount = rewardToken.balanceOf(address(this)) - crvBalanceBefore;
```




- Estimated gas saved = Estimated gas saved: This optimization could save around 800 to 1,000 gas per call to [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L160C4-L196C6), as the ``SLOAD`` opcode costs 800 gas.

Possible Optimization 2 = 
- Similarly, in the [_withdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L229C2-L254C6) function, there are two calls to ``lpToken.balanceOf(address(this))`` [before](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L236C3-L236C59) and [after](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L243C7-L243C56) the [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L238C9-L238C26) and [lpGauge.withdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L240C7-L240C47) calls. This can be optimized by storing the balance in a variable before the [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L238C9-L238C26) and [lpGauge.withdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L240C7-L240C47) calls and then subtracting the withdrawn amount from the stored balance.


After Optimization: 




```solidity
uint256 queued = lpToken.balanceOf(address(this));
if (amount > queued) {
    compound("");
    uint256 lpBalance = lpGauge.balanceOf(address(this));
    lpGauge.withdraw(lpBalance, true);
    queued -= lpBalance;
}
require(
    queued >= amount,
    "TricryptoLPStrategy: not enough"
);
```




- Estimated gas saved = This optimization could save around 800 to 1,000 gas per call to [_withdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/curve/TricryptoLPStrategy.sol#L229C2-L254C6), as the ``SLOAD`` opcode costs 800 gas.

### Possible Optimizations in [StargateStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol)
Possible Optimization 1 = 
- In the [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L159C4-L190C6) function, there are two calls to ``stgTokenReward.balanceOf(address(this))`` [before](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L166C13-L166C80) and [after](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L168C9-L168C79) the [lpStaking.deposit(2, 0)](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L167C10-L167C37) call. This can be optimized by storing the balance in a variable before the deposit operation and then subtracting it from the balance after the deposit operation.


After Optimization:




```solidity
uint256 stgBalanceBefore = stgTokenReward.balanceOf(address(this));
lpStaking.deposit(2, 0);
uint256 stgAmount = stgTokenReward.balanceOf(address(this)) - stgBalanceBefore;
```




- Estimated gas saved = This optimization could save around 800 to 1,000 gas per call to [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L159C4-L190C6), as the ``SLOAD`` opcode costs 800 gas.

Possible Optimization 2 = 
- In the [_withdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L241C4-L270C1) function, there are two calls to ``wrappedNative.balanceOf(address(this))`` [before](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L248C7-L248C65) and [after](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L263C1-L263C62) the [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L250C12-L250C26) and [lpStaking.withdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L252C1-L252C1) calls. This can be optimized by storing the balance in a variable before the [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L250C12-L250C26) and [lpStaking.withdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L252C1-L252C1) calls and then subtracting the withdrawn amount from the stored balance.


After Optimization: 




```solidity
uint256 queued = wrappedNative.balanceOf(address(this));
if (amount > queued) {
    compound("");
    uint256 toWithdraw = amount - queued;
    lpStaking.withdraw(lpStakingPid, toWithdraw);
    queued -= toWithdraw;
}
require(
    queued >= amount,
    "Stargate: not enough"
);
```




- Estimated gas saved = This optimization could save around 800 to 1,000 gas per call to [_withdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/stargate/StargateStrategy.sol#L241C4-L270C1), as the ``SLOAD`` opcode costs 800 gas.

### Possible Optimization in [AaveStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/aave/AaveStrategy.sol)
Possible Optimization = 
- In the [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/aave/AaveStrategy.sol#L138C5-L206C6) function, there are two calls to ``rewardToken.balanceOf(address(this))`` [before](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/aave/AaveStrategy.sol#L139C2-L139C74) and [after](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/aave/AaveStrategy.sol#L167C4-L167C79) the [incentivesController.claimRewards](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/aave/AaveStrategy.sol#L148C13-L152C15) call. This can be optimized by storing the balance in a variable before the claim operation and then subtracting it from the balance after the claim operation.

After Optimization:




```solidity
uint256 aaveBalanceBefore = rewardToken.balanceOf(address(this));
//first claim stkAave
uint256 unclaimedStkAave = incentivesController.getUserUnclaimedRewards(
    address(this)
);
if (unclaimedStkAave > 0) {
    address[] memory tokens = new address[](1);
    tokens[0] = address(receiptToken);
    incentivesController.claimRewards(
        tokens,
        type(uint256).max,
        address(this)
    );
}
//try to claim AAVE
uint256 claimable = stakedRewardToken.stakerRewardsToClaim(
    address(this)
);
if (claimable > 0) {
    stakedRewardToken.claimRewards(address(this), claimable);
}
uint256 aaveAmount = rewardToken.balanceOf(address(this)) - aaveBalanceBefore;
```




- Estimated gas saved = This optimization could save around 800 to 1,000 gas per call to [compound](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/aave/AaveStrategy.sol#L138C5-L206C6), as the ``SLOAD`` opcode costs 800 gas.

### Possible Optimization in [BalancerStrategy.sol](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/balancer/BalancerStrategy.sol)
Possible Optimization = 
- In the [_withdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/balancer/BalancerStrategy.sol#L191C1-L216C6) function, there are two calls to ``wrappedNative.balanceOf(address(this))`` [before](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/balancer/BalancerStrategy.sol#L198C9-L198C65) and [after](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/balancer/BalancerStrategy.sol#L209C8-L209C62) the [_vaultWithdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/balancer/BalancerStrategy.sol#L205C3-L205C40) call. This can be optimized by storing the balance in a variable before the [_vaultWithdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/balancer/BalancerStrategy.sol#L205C3-L205C40) call and then subtracting the withdrawn amount from the stored balance.

After Optimization:




```solidity
uint256 queued = wrappedNative.balanceOf(address(this));
if (amount > queued) {
    uint256 toWithdraw = amount - queued;
    queued -= _vaultWithdraw(toWithdraw);
}
require(
    queued >= amount,
    "BalancerStrategy: not enough"
);
wrappedNative.safeTransfer(to, amount);
```




- Estimated gas saved = This optimization could save around 800 to 1,000 gas per call to [_withdraw](https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/master/contracts/balancer/BalancerStrategy.sol#L191C1-L216C6), as the ``SLOAD`` opcode costs 800 gas.